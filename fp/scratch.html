
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - pointerlock controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}

		</style>
	</head>
	<body>
		<script src="three.js-master/build/three.js"></script>


		<script>

			var camera, scene, renderer, controls;

			var objects = [];
			var holes = [];
			var treasures = [];
			var holeposx  = [60];
			var holeposz = [-40];
			var treasuresget;


			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;
			var falling = false;
			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();
			var box2;
			var player;
			var box;
			var flagx;
			var flagz;
			var wallheight = 500;
			var walllength = [20, 440, 20, 520, 20, 380, 280, 120, 120, 20, 20, 20, 360, 40];
			var wallwidth = [380, 20, 360, 20, 100, 20, 20, 20, 20, 160, 80, 100, 20, 160];
			var wallposx = [10, 320, 530, 280, 110, 290, 380, 460, 460, 190, 250, 310, 340, 100];
			var wallposz = [190, 10, 180, 370, 70, 130, 190, 270, 310, 280, 320, 310, 70, 260];
			var viewmode = 0;
			var onground;
			var treasureget = 0;
			var startposx = 60;
			var startposz = 10;
			var startposy = 10;
			var campos = 50;
			var holesize = 30;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );
				scene.fog = new THREE.Fog( 0xffffff, 0, 750 );

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );

				
				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							flagx = 0;
							flagz = 1;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							flagx = 1;
							flagz = 0;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							flagx = 0;
							flagz = 1;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							flagx = 1;
							flagz = 0;
							break;

						case 32: // space
							if ( canJump === true )
							{
								velocity.y += 500;
								onground = 0;
							}
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;
						case 13: //enter
							viewmode += 1;
							viewmode = viewmode%4;
							if(viewmode == 0)
							{
								camera.position.x = box2.position.x;
								camera.position.y = box2.position.y + campos;
								camera.position.z = box2.position.z + campos;
							}
							else if(viewmode == 1)
							{
								camera.position.x = box2.position.x - campos;
								camera.position.y = box2.position.y + campos;
								camera.position.z = box2.position.z;
							}
							else if(viewmode == 2)
							{
								camera.position.x = box2.position.x;
								camera.position.y = box2.position.y + campos;
								camera.position.z = box2.position.z - campos;
							}
							else if(viewmode == 3)
							{
								camera.position.x = box2.position.x + campos;
								camera.position.y = box2.position.y + campos;
								camera.position.z = box2.position.z;
							}
							camera.lookAt(box2.position)
							break;
						case 90:
							//alert((box.position.x - treasure.position.x)*(box.position.x - treasure.position.x) + (box.position.z - treasure.position.z)*(box.position.z - treasure.position.z));
							treasureget = 1;
							if((box2.position.x - treasure.position.x)*(box2.position.x - treasure.position.x) + (box2.position.z - treasure.position.z)*(box2.position.z - treasure.position.z) < 500)
							{
								alert("you get the treasure");
							}
							break;
							
							

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );


				// floor

				var floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100);
				floorGeometry.rotateX( - Math.PI / 2 );

				var floorMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

				var floor = new THREE.Mesh( floorGeometry, floorMaterial );
				scene.add( floor );
				
				for(var j = 0; j< holeposx.length; j++)
				{
					var holeGeometry = new THREE.PlaneGeometry( holesize, holesize, 100);
					holeGeometry.rotateX( - Math.PI / 2 );
					var holeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000 } );
					var hole1 = new THREE.Mesh(holeGeometry, holeMaterial);
					hole1.position.x = holeposx[j];
					hole1.position.y = 1;
					hole1.position.z = holeposz[j];
				
					scene.add(hole1);
					holes.push(hole1);
				}
				
				
				var treasureGeometry = new THREE.BoxGeometry( 20, 20, 20 );
				var treasureMaterial = new THREE.MeshPhongMaterial( { specular: 0xffff00, flatShading: true, vertexColors: THREE.VertexColors } );
				var treasure = new THREE.Mesh(treasureGeometry, treasureMaterial);
				treasure.position.x = 510;
				treasure.position.z = 340;
				
				scene.add(treasure);
				
				
				
				// objects
				for(var i = 0; i< walllength.length ; i++)
				{
					var boxGeometry = new THREE.BoxGeometry( walllength[i], wallheight, wallwidth[i] );

					var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
					var box = new THREE.Mesh( boxGeometry, boxMaterial );
					box.position.x = wallposx[i];
					box.position.z = wallposz[i];
					scene.add(box);
					objects.push(box);
				}
				
				
				var box2Geometry = new THREE.BoxGeometry( 20, 20, 20 );
				var box2Material = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
				box2 = new THREE.Mesh( box2Geometry, box2Material );
				box2.position.x = startposx;
				box2.position.z = startposz;
				scene.add(box2);
				camera.position.set(startposx,startposy+campos,startposz+campos);
				camera.lookAt(box2.position);
				

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

					
					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;
					
					direction.z = (Number( moveForward ) - Number( moveBackward ))*flagz;
					direction.x = (Number( moveLeft ) - Number( moveRight ))*flagx;
					direction.normalize();
					//velocity.x -= velocity.x * 10.0 * delta;
					//velocity.z -= velocity.z * 10.0 * delta;
					
					velocity.x = 0;
					velocity.z = 0;
					if(onground && falling == false)
					{
						velocity.y = 0;
					}
					else
					{
						velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
					}
					
					

					if ( moveForward )
					{
						velocity.z -=  direction.z * 2000.0 * delta ;
					}					
					if ( moveBackward ) 
					{
						velocity.z -=  direction.z * 2000.0 * delta;
					}
					if ( moveLeft) 
					{
						velocity.x -= direction.x * 2000.0 * delta;
					}
					if ( moveRight ) 
					{
						velocity.x -= direction.x * 2000.0 * delta;
					}
					
					if(viewmode == 0)
					{
						box2.translateX( velocity.x * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( velocity.z * delta );
					
						camera.position.x = box2.position.x;
						camera.position.y = box2.position.y + campos;
						camera.position.z = box2.position.z + campos;
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength[i]/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength[i]/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth[i]/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth[i]/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.x > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength[i]/2 - 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.x < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength[i]/2 + 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.z > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth[i]/2 - 10;
									camera.position.z = box2.position.z +campos;
								}
								if(velocity.z < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth[i]/2 + 10;
									camera.position.z = box2.position.z + campos;
								}
						
						}
					}
					}
					else if(viewmode == 1)
					{
						box2.translateX( -velocity.z * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( velocity.x * delta );
					
						camera.position.x = box2.position.x - campos;
						camera.position.y = box2.position.y + campos;
						camera.position.z = box2.position.z;
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength[i]/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength[i]/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth[i]/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth[i]/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.z < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength[i]/2 - 10;
									camera.position.x = box2.position.x-campos;
								}
								if(velocity.z > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength[i]/2 + 10;
									camera.position.x = box2.position.x-campos;
								}
								if(velocity.x > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth[i]/2 - 10;
									camera.position.z = box2.position.z;
								}
								if(velocity.x < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth[i]/2 + 10;
									camera.position.z = box2.position.z;
								}
							}
						
						}
					}
					else if(viewmode == 2)
					{
						box2.translateX( -velocity.x * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( -velocity.z * delta );
					
						camera.position.x = box2.position.x;
						camera.position.y = box2.position.y + campos;
						camera.position.z = box2.position.z - campos;
						
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength[i]/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength[i]/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth[i]/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth[i]/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.x < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength[i]/2 - 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.x > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength[i]/2 + 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.z < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth[i]/2 - 10;
									camera.position.z = box2.position.z -campos;
								}
								if(velocity.z > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth[i]/2 + 10;
									camera.position.z = box2.position.z - campos;
								}
							}
						}
					}
					else if(viewmode == 3)
					{
						box2.translateX( velocity.z * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( -velocity.x * delta );
					
						camera.position.x = box2.position.x + campos;
						camera.position.y = box2.position.y + campos;
						camera.position.z = box2.position.z;
						
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength[i]/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength[i]/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth[i]/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth[i]/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.z > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength[i]/2 - 10;
									camera.position.x = box2.position.x + campos;
								}
								if(velocity.z < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength[i]/2 + 10;
									camera.position.x = box2.position.x + campos;
								}
								if(velocity.x < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth[i]/2 - 10;
									camera.position.z = box2.position.z;
								}
								if(velocity.x > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth[i]/2 + 10;
									camera.position.z = box2.position.z;
								}
							}
						}
					}

					
					for(var i = 0; i<holes.length ; i++)
					{
						if(box2.position.x > holes[i].position.x - holesize/2 && box2.position.x < holes[i].position.x + holesize/2 && box2.position.z > holes[i].position.z - holesize/2 && box2.position.z  < holes[i].position.z + holesize/2)
						{
							falling = true;
							break;
						}
						falling = false;
					}
					
					
					

					if ( box2.position.y < 10 ) {
						if(falling === false)
						{
							onground = 1;
							velocity.y = 0;
							box2.position.y = 10;

							canJump = true;
						}
						if(box2.position.y < -100)
						{
							box2.position.x = startposx;
							box2.position.z = startposz;
							falling = false;
							
							viewmode = 0;
							
							camera.position.x = box2.position.x;
							camera.position.z = box2.position.z + campos;
							
							camera.lookAt(box2.position);
							
						}
						

					}
					
					if(treasureget == 1)
					{
						treasureget = 0;
						
					}
					
					
					
					
					
					
					

					prevTime = time;


				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
