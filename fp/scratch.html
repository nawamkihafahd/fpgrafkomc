
<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js - pointerlock controls</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
			}

			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
				font-family: arial;
			}

			#blocker {

				position: absolute;

				width: 100%;
				height: 100%;

				background-color: rgba(0,0,0,0.5);

			}

			#instructions {

				width: 100%;
				height: 100%;

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;

				cursor: pointer;

			}

		</style>
	</head>
	<body>
		<script src="three.js-master/build/three.js"></script>


		<script>

			var camera, scene, renderer, controls;

			var objects = [];
			var holes = [];
			var treasures = [];
			var treasuresget;


			var moveForward = false;
			var moveBackward = false;
			var moveLeft = false;
			var moveRight = false;
			var canJump = false;

			var prevTime = performance.now();
			var velocity = new THREE.Vector3();
			var direction = new THREE.Vector3();
			var vertex = new THREE.Vector3();
			var color = new THREE.Color();
			var box2;
			var player;
			var box;
			var flagx;
			var flagz;
			var wallheight = 500;
			var walllength = 20;
			var wallwidth = 100;
			var viewmode = 0;
			var onground;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1000 );

				scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xffffff );
				scene.fog = new THREE.Fog( 0xffffff, 0, 750 );

				var light = new THREE.HemisphereLight( 0xeeeeff, 0x777788, 0.75 );
				light.position.set( 0.5, 1, 0.75 );
				scene.add( light );

				
				var onKeyDown = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = true;
							flagx = 0;
							flagz = 1;
							break;

						case 37: // left
						case 65: // a
							moveLeft = true;
							flagx = 1;
							flagz = 0;
							break;

						case 40: // down
						case 83: // s
							moveBackward = true;
							flagx = 0;
							flagz = 1;
							break;

						case 39: // right
						case 68: // d
							moveRight = true;
							flagx = 1;
							flagz = 0;
							break;

						case 32: // space
							if ( canJump === true )
							{
								velocity.y += 350;
								onground = 0;
							}
							canJump = false;
							break;

					}

				};

				var onKeyUp = function ( event ) {

					switch ( event.keyCode ) {

						case 38: // up
						case 87: // w
							moveForward = false;
							break;

						case 37: // left
						case 65: // a
							moveLeft = false;
							break;

						case 40: // down
						case 83: // s
							moveBackward = false;
							break;

						case 39: // right
						case 68: // d
							moveRight = false;
							break;
						case 13: //enter
							viewmode += 1;
							viewmode = viewmode%4;
							if(viewmode == 0)
							{
								camera.position.x = box2.position.x;
								camera.position.y = box2.position.y + 100;
								camera.position.z = box2.position.z + 100;
							}
							else if(viewmode == 1)
							{
								camera.position.x = box2.position.x - 100;
								camera.position.y = box2.position.y + 100;
								camera.position.z = box2.position.z;
							}
							else if(viewmode == 2)
							{
								camera.position.x = box2.position.x;
								camera.position.y = box2.position.y + 100;
								camera.position.z = box2.position.z - 100;
							}
							else if(viewmode == 3)
							{
								camera.position.x = box2.position.x + 100;
								camera.position.y = box2.position.y + 100;
								camera.position.z = box2.position.z;
							}
							camera.lookAt(box2.position)
							break;

					}

				};

				document.addEventListener( 'keydown', onKeyDown, false );
				document.addEventListener( 'keyup', onKeyUp, false );


				// floor

				var floorGeometry = new THREE.PlaneGeometry( 2000, 2000, 100);
				floorGeometry.rotateX( - Math.PI / 2 );

				var floorMaterial = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

				var floor = new THREE.Mesh( floorGeometry, floorMaterial );
				scene.add( floor );

				// objects

				var boxGeometry = new THREE.BoxGeometry( walllength, wallheight, wallwidth );

				var boxMaterial = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
				box = new THREE.Mesh( boxGeometry, boxMaterial );
				box.position.x = 100;
				box.position.z = 0;
				scene.add(box);
				objects.push(box);
				
				var box3Geometry = new THREE.BoxGeometry( walllength, wallheight, wallwidth );
				var box3Material = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
				box3 = new THREE.Mesh( box3Geometry, box3Material );
				box3.position.x = 100;
				box3.position.z = 100;
				scene.add(box3);
				objects.push(box3);
				
				var box2Geometry = new THREE.BoxGeometry( 20, 20, 20 );
				var box2Material = new THREE.MeshPhongMaterial( { specular: 0xffffff, flatShading: true, vertexColors: THREE.VertexColors } );
				box2 = new THREE.Mesh( box2Geometry, box2Material );
				box2.position.x = 0;
				box2.position.z = 0;
				scene.add(box2);
				camera.position.set(0,100,100);
				camera.lookAt(box2.position);
				

				//

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function animate() {

				requestAnimationFrame( animate );

					
					var time = performance.now();
					var delta = ( time - prevTime ) / 1000;
					
					direction.z = (Number( moveForward ) - Number( moveBackward ))*flagz;
					direction.x = (Number( moveLeft ) - Number( moveRight ))*flagx;
					direction.normalize();
					//velocity.x -= velocity.x * 10.0 * delta;
					//velocity.z -= velocity.z * 10.0 * delta;
					
					velocity.x = 0;
					velocity.z = 0;
					if(onground)
					{
						velocity.y = 0;
					}
					else
					{
						velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass
					}
					
					

					if ( moveForward )
					{
						velocity.z -=  direction.z * 1200.0 * delta ;
					}					
					if ( moveBackward ) 
					{
						velocity.z -=  direction.z * 1200.0 * delta;
					}
					if ( moveLeft) 
					{
						velocity.x -= direction.x * 1200.0 * delta;
					}
					if ( moveRight ) 
					{
						velocity.x -= direction.x * 1200.0 * delta;
					}
					
					if(viewmode == 0)
					{
						box2.translateX( velocity.x * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( velocity.z * delta );
					
						camera.position.x = box2.position.x;
						camera.position.y = box2.position.y + 100;
						camera.position.z = box2.position.z + 100;
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.x > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength/2 - 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.x < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength/2 + 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.z > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth/2 - 10;
									camera.position.z = box2.position.z +100;
								}
								if(velocity.z < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth/2 + 10;
									camera.position.z = box2.position.z + 100;
								}
						
						}
					}
					}
					else if(viewmode == 1)
					{
						box2.translateX( -velocity.z * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( velocity.x * delta );
					
						camera.position.x = box2.position.x - 100;
						camera.position.y = box2.position.y + 100;
						camera.position.z = box2.position.z;
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.z < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength/2 - 10;
									camera.position.x = box2.position.x-100;
								}
								if(velocity.z > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength/2 + 10;
									camera.position.x = box2.position.x-100;
								}
								if(velocity.x > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth/2 - 10;
									camera.position.z = box2.position.z;
								}
								if(velocity.x < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth/2 + 10;
									camera.position.z = box2.position.z;
								}
							}
						
						}
					}
					else if(viewmode == 2)
					{
						box2.translateX( -velocity.x * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( -velocity.z * delta );
					
						camera.position.x = box2.position.x;
						camera.position.y = box2.position.y + 100;
						camera.position.z = box2.position.z - 100;
						
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.x < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength/2 - 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.x > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength/2 + 10;
									camera.position.x = box2.position.x;
								}
								if(velocity.z < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth/2 - 10;
									camera.position.z = box2.position.z -100;
								}
								if(velocity.z > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth/2 + 10;
									camera.position.z = box2.position.z - 100;
								}
							}
						}
					}
					else if(viewmode == 3)
					{
						box2.translateX( velocity.z * delta );
						box2.translateY( velocity.y * delta );
						box2.translateZ( -velocity.x * delta );
					
						camera.position.x = box2.position.x + 100;
						camera.position.y = box2.position.y + 100;
						camera.position.z = box2.position.z;
						
						
						for(var i = 0; i<objects.length ; i++)
						{
							if(((box2.position.x + 10) > (objects[i].position.x -walllength/2)&& (box2.position.x - 10) < (objects[i].position.x+walllength/2)) && ((box2.position.z + 10) > (objects[i].position.z -wallwidth/2)&& (box2.position.z - 10) < (objects[i].position.z+wallwidth/2)) && ((box2.position.y + 10) > (objects[i].position.y -wallheight/2)&& (box2.position.y - 10) < (objects[i].position.y+wallheight/2)))
							{
								if(velocity.z > 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x - walllength/2 - 10;
									camera.position.x = box2.position.x + 100;
								}
								if(velocity.z < 0)
								{
									flagx = 0;
									box2.position.x = objects[i].position.x + walllength/2 + 10;
									camera.position.x = box2.position.x + 100;
								}
								if(velocity.x < 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z - wallwidth/2 - 10;
									camera.position.z = box2.position.z;
								}
								if(velocity.x > 0)
								{
									flagz = 0;
									box2.position.z = objects[i].position.z + wallwidth/2 + 10;
									camera.position.z = box2.position.z;
								}
							}
						}
					}

					
					
					
					
					

					if ( box2.position.y < 10 ) {
						onground = 1;
						velocity.y = 0;
						box2.position.y = 10;

						canJump = true;

					}
					
					
					
					
					
					
					

					prevTime = time;


				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
